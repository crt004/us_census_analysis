}
ideal <- rbind(ideal1, ideal2, ideal3, ideal4, ideal5, ideal6, ideal7, ideal8, ideal9, ideal10 )
prediction <- rbind(prediction1, prediction2, prediction3, prediction4, prediction5,
prediction6, prediction7, prediction8, prediction9, prediction10 )
confusionMatrix(prediction, ideal)
#extract instance_weight and the features with excess of NA
train <- train.raw
columns_to_drop = c("migration_code-change_in_msa",
"migration_code-change_in_reg",
"migration_code-move_within_reg",
"migration_prev_res_in_sunbelt",
"instance_weight")
train <- train.raw
#extract instance_weight
columns_to_drop = c("instance_weight")
train = train[,-which(names(train) %in% columns_to_drop)]
# create get_mode function
get_mode <- function(x){
uniq <- na.omit(unique(x))
uniq[which.max(tabulate(match(x, uniq)))]
}
#replace the NA values for the mode of the column
for(c in columns_with_na){
if (!(c %in% columns_to_drop)){
train[is.na(train[,c]), c] <- get_mode(train[[c]])
}
}
train.names <- names(train)[1:ncol(train) ]
cat("convert categorical variables from string to integer\n")
for (f in train.names) {
if (!(f %in% numeric_columns_data)){
train[[f]] <- as.integer(train[[f]])
}
}
train$target = train$target - 1
#library(Metrics)
#library(caret)
n_folds = 10
folds_i = sample(rep(1:n_folds, length.out = nrow(train)))
cv_tmp <- matrix(NA,nrow = n_folds, ncol = length(train))
global_misClasificError = 0
for(k in 1:n_folds){
test_i <- which(folds_i == k)
train_ <- train[-test_i,]
test_ <- train[test_i,]
model <- glm(train_$target ~.,family=binomial(link='logit'),data=train_)
prediction = predict(model, test_, type="response")
fitted.results <- ifelse(prediction > 0.5,1,0)
misClasificError <- mean(fitted.results != test_$target)
print(paste('Accuracy fold',k,'-' ,1-misClasificError))
global_misClasificError = global_misClasificError + (1-misClasificError)
if( k==1 ) ideal1 <- test_$target
if( k==2 ) ideal2 <- test_$target
if( k==3 ) ideal3 <- test_$target
if( k==4 ) ideal4 <- test_$target
if( k==5 ) ideal5 <- test_$target
if( k==6 ) ideal6 <- test_$target
if( k==7 ) ideal7 <- test_$target
if( k==8 ) ideal8 <- test_$target
if( k==9 ) ideal9 <- test_$target
if( k==10 ) ideal10 <- test_$target
if( k==1 ) prediction1 <- fitted.results
if( k==2 ) prediction2 <- fitted.results
if( k==3 ) prediction3 <- fitted.results
if( k==4 ) prediction4 <- fitted.results
if( k==5 ) prediction5 <- fitted.results
if( k==6 ) prediction6 <- fitted.results
if( k==7 ) prediction7 <- fitted.results
if( k==8 ) prediction8 <- fitted.results
if( k==9 ) prediction9 <- fitted.results
if( k==10 ) prediction10 <- fitted.results
}
ideal <- rbind(ideal1, ideal2, ideal3, ideal4, ideal5, ideal6, ideal7, ideal8, ideal9, ideal10 )
prediction <- rbind(prediction1, prediction2, prediction3, prediction4, prediction5,
prediction6, prediction7, prediction8, prediction9, prediction10 )
confusionMatrix(prediction, ideal)
columns_to_drop = c("capital_gains",
"wage_per_hour",
"capital_losses",
"dividends_from_stocks",
"migration_code-change_in_msa",
"migration_code-change_in_reg",
"migration_code-move_within_reg",
"migration_prev_res_in_sunbelt",
"instance_weight")
train <- train.raw
#extract instance_weight
columns_to_drop = c("instance_weight")
train = train[,-which(names(train) %in% columns_to_drop)]
# create get_mode function
get_mode <- function(x){
uniq <- na.omit(unique(x))
uniq[which.max(tabulate(match(x, uniq)))]
}
#replace the NA values for the mode of the column
for(c in columns_with_na){
if (!(c %in% columns_to_drop)){
train[is.na(train[,c]), c] <- get_mode(train[[c]])
}
}
train.names <- names(train)[1:ncol(train) ]
cat("convert categorical variables from string to integer\n")
for (f in train.names) {
if (!(f %in% numeric_columns_data)){
train[[f]] <- as.integer(train[[f]])
}
}
train$target = train$target - 1
#library(Metrics)
#library(caret)
n_folds = 10
folds_i = sample(rep(1:n_folds, length.out = nrow(train)))
cv_tmp <- matrix(NA,nrow = n_folds, ncol = length(train))
global_misClasificError = 0
for(k in 1:n_folds){
test_i <- which(folds_i == k)
train_ <- train[-test_i,]
test_ <- train[test_i,]
model <- glm(train_$target ~.,family=binomial(link='logit'),data=train_)
prediction = predict(model, test_, type="response")
fitted.results <- ifelse(prediction > 0.5,1,0)
misClasificError <- mean(fitted.results != test_$target)
print(paste('Accuracy fold',k,'-' ,1-misClasificError))
global_misClasificError = global_misClasificError + (1-misClasificError)
if( k==1 ) ideal1 <- test_$target
if( k==2 ) ideal2 <- test_$target
if( k==3 ) ideal3 <- test_$target
if( k==4 ) ideal4 <- test_$target
if( k==5 ) ideal5 <- test_$target
if( k==6 ) ideal6 <- test_$target
if( k==7 ) ideal7 <- test_$target
if( k==8 ) ideal8 <- test_$target
if( k==9 ) ideal9 <- test_$target
if( k==10 ) ideal10 <- test_$target
if( k==1 ) prediction1 <- fitted.results
if( k==2 ) prediction2 <- fitted.results
if( k==3 ) prediction3 <- fitted.results
if( k==4 ) prediction4 <- fitted.results
if( k==5 ) prediction5 <- fitted.results
if( k==6 ) prediction6 <- fitted.results
if( k==7 ) prediction7 <- fitted.results
if( k==8 ) prediction8 <- fitted.results
if( k==9 ) prediction9 <- fitted.results
if( k==10 ) prediction10 <- fitted.results
}
ideal <- rbind(ideal1, ideal2, ideal3, ideal4, ideal5, ideal6, ideal7, ideal8, ideal9, ideal10 )
prediction <- rbind(prediction1, prediction2, prediction3, prediction4, prediction5,
prediction6, prediction7, prediction8, prediction9, prediction10 )
confusionMatrix(prediction, ideal)
getwd()
path="/Users/ctrabuco/Desktop/us_census_full/code"
setwd(path)
# Input data files are available in the "../input/" directory.
cat("reading the train and test data\n")
train.raw  <- read.csv("../input/census_income_learn.csv",head=FALSE, na.strings=c("?"," ?"))
test.raw  <- read.csv("../input/census_income_test.csv",head=FALSE, na.strings = "?")
columns_data <- c("age",
"class_of_worker",
"detailed_industry_recode",
"detailed_occupation_recode",
"education",
"wage_per_hour",
"enroll_in_edu_inst_last_wk",
"marital_stat",
"major_industry_code",
"major_occupation_code",
"race",
"hispanic_origin",
"sex",
"member_of_a_labor_union",
"reason_for_unemployment",
"full_or_part_time_employment_stat",
"capital_gains",
"capital_losses",
"dividends_from_stocks",
"tax_filer_stat",
"region_of_previous_residence",
"state_of_previous_residence",
"detailed_household_and_family_stat",
"detailed_household_summary_in_hous",
"instance_weight", # ignore (?)
"migration_code-change_in_msa",
"migration_code-change_in_reg",
"migration_code-move_within_reg",
"live_in_this_house_1_year_ago",
"migration_prev_res_in_sunbelt",
"num_persons_worked_for_employer",
"family_members_under_18",
"country_of_birth_father",
"country_of_birth_mother",
"country_of_birth_self",
"citizenship",
"own_business_or_self_employed",
"fill_inc_questionnaire_for_veteran",
"veterans_benefits",
"weeks_worked_in_year",
"year",
"target")
numeric_columns_data <- c("age",
"wage_per_hour",
"capital_gains",
"capital_losses",
"dividends_from_stocks",
"num_persons_worked_for_employer",
"weeks_worked_in_year")
# columns that contain any NA,
# (after analysis in previous phase I found they are the same in train and test)
columns_with_na = c("state_of_previous_residence",
"migration_code-change_in_msa",
"migration_code-change_in_reg",
"migration_code-move_within_reg",
"migration_prev_res_in_sunbelt",
"country_of_birth_father",
"country_of_birth_mother",
"country_of_birth_self")
colnames(train.raw) <- columns_data
###################################################
# MODEL 1 : Logistic Regression
###################################################
train <- train.raw
#extract instance_weight
columns_to_drop = c("instance_weight")
train = train[,-which(names(train) %in% columns_to_drop)]
# create get_mode function
get_mode <- function(x){
uniq <- na.omit(unique(x))
uniq[which.max(tabulate(match(x, uniq)))]
}
#replace the NA values for the mode of the column
for(c in columns_with_na){
if (!(c %in% columns_to_drop)){
train[is.na(train[,c]), c] <- get_mode(train[[c]])
}
}
train.names <- names(train)[1:ncol(train) ]
cat("convert categorical variables from string to integer\n")
for (f in train.names) {
if (!(f %in% numeric_columns_data)){
train[[f]] <- as.integer(train[[f]])
}
}
train$target = train$target - 1
#library(Metrics)
#library(caret)
n_folds = 10
folds_i = sample(rep(1:n_folds, length.out = nrow(train)))
cv_tmp <- matrix(NA,nrow = n_folds, ncol = length(train))
global_misClasificError = 0
for(k in 1:n_folds){
test_i <- which(folds_i == k)
train_ <- train[-test_i,]
test_ <- train[test_i,]
model <- glm(train_$target ~.,family=binomial(link='logit'),data=train_)
prediction = predict(model, test_, type="response")
fitted.results <- ifelse(prediction > 0.5,1,0)
misClasificError <- mean(fitted.results != test_$target)
print(paste('Accuracy fold',k,'-' ,1-misClasificError))
global_misClasificError = global_misClasificError + (1-misClasificError)
if( k==1 ) ideal1 <- test_$target
if( k==2 ) ideal2 <- test_$target
if( k==3 ) ideal3 <- test_$target
if( k==4 ) ideal4 <- test_$target
if( k==5 ) ideal5 <- test_$target
if( k==6 ) ideal6 <- test_$target
if( k==7 ) ideal7 <- test_$target
if( k==8 ) ideal8 <- test_$target
if( k==9 ) ideal9 <- test_$target
if( k==10 ) ideal10 <- test_$target
if( k==1 ) prediction1 <- fitted.results
if( k==2 ) prediction2 <- fitted.results
if( k==3 ) prediction3 <- fitted.results
if( k==4 ) prediction4 <- fitted.results
if( k==5 ) prediction5 <- fitted.results
if( k==6 ) prediction6 <- fitted.results
if( k==7 ) prediction7 <- fitted.results
if( k==8 ) prediction8 <- fitted.results
if( k==9 ) prediction9 <- fitted.results
if( k==10 ) prediction10 <- fitted.results
}
ideal <- rbind(ideal1, ideal2, ideal3, ideal4, ideal5, ideal6, ideal7, ideal8, ideal9, ideal10 )
prediction <- rbind(prediction1, prediction2, prediction3, prediction4, prediction5,
prediction6, prediction7, prediction8, prediction9, prediction10 )
confusionMatrix(prediction, ideal)
#extract instance_weight and the features with excess of NA
train <- train.raw
columns_to_drop = c("migration_code-change_in_msa",
"migration_code-change_in_reg",
"migration_code-move_within_reg",
"migration_prev_res_in_sunbelt",
"instance_weight")
train <- train.raw
#extract instance_weight
columns_to_drop = c("instance_weight")
train = train[,-which(names(train) %in% columns_to_drop)]
# create get_mode function
get_mode <- function(x){
uniq <- na.omit(unique(x))
uniq[which.max(tabulate(match(x, uniq)))]
}
#replace the NA values for the mode of the column
for(c in columns_with_na){
if (!(c %in% columns_to_drop)){
train[is.na(train[,c]), c] <- get_mode(train[[c]])
}
}
train.names <- names(train)[1:ncol(train) ]
cat("convert categorical variables from string to integer\n")
for (f in train.names) {
if (!(f %in% numeric_columns_data)){
train[[f]] <- as.integer(train[[f]])
}
}
train$target = train$target - 1
#library(Metrics)
#library(caret)
n_folds = 10
folds_i = sample(rep(1:n_folds, length.out = nrow(train)))
cv_tmp <- matrix(NA,nrow = n_folds, ncol = length(train))
global_misClasificError = 0
for(k in 1:n_folds){
test_i <- which(folds_i == k)
train_ <- train[-test_i,]
test_ <- train[test_i,]
model <- glm(train_$target ~.,family=binomial(link='logit'),data=train_)
prediction = predict(model, test_, type="response")
fitted.results <- ifelse(prediction > 0.5,1,0)
misClasificError <- mean(fitted.results != test_$target)
print(paste('Accuracy fold',k,'-' ,1-misClasificError))
global_misClasificError = global_misClasificError + (1-misClasificError)
if( k==1 ) ideal1 <- test_$target
if( k==2 ) ideal2 <- test_$target
if( k==3 ) ideal3 <- test_$target
if( k==4 ) ideal4 <- test_$target
if( k==5 ) ideal5 <- test_$target
if( k==6 ) ideal6 <- test_$target
if( k==7 ) ideal7 <- test_$target
if( k==8 ) ideal8 <- test_$target
if( k==9 ) ideal9 <- test_$target
if( k==10 ) ideal10 <- test_$target
if( k==1 ) prediction1 <- fitted.results
if( k==2 ) prediction2 <- fitted.results
if( k==3 ) prediction3 <- fitted.results
if( k==4 ) prediction4 <- fitted.results
if( k==5 ) prediction5 <- fitted.results
if( k==6 ) prediction6 <- fitted.results
if( k==7 ) prediction7 <- fitted.results
if( k==8 ) prediction8 <- fitted.results
if( k==9 ) prediction9 <- fitted.results
if( k==10 ) prediction10 <- fitted.results
}
ideal <- rbind(ideal1, ideal2, ideal3, ideal4, ideal5, ideal6, ideal7, ideal8, ideal9, ideal10 )
prediction <- rbind(prediction1, prediction2, prediction3, prediction4, prediction5,
prediction6, prediction7, prediction8, prediction9, prediction10 )
confusionMatrix(prediction, ideal)
columns_to_drop = c("capital_gains",
"wage_per_hour",
"capital_losses",
"dividends_from_stocks",
"migration_code-change_in_msa",
"migration_code-change_in_reg",
"migration_code-move_within_reg",
"migration_prev_res_in_sunbelt",
"instance_weight")
train <- train.raw
#extract instance_weight
columns_to_drop = c("instance_weight")
train = train[,-which(names(train) %in% columns_to_drop)]
# create get_mode function
get_mode <- function(x){
uniq <- na.omit(unique(x))
uniq[which.max(tabulate(match(x, uniq)))]
}
#replace the NA values for the mode of the column
for(c in columns_with_na){
if (!(c %in% columns_to_drop)){
train[is.na(train[,c]), c] <- get_mode(train[[c]])
}
}
train.names <- names(train)[1:ncol(train) ]
cat("convert categorical variables from string to integer\n")
for (f in train.names) {
if (!(f %in% numeric_columns_data)){
train[[f]] <- as.integer(train[[f]])
}
}
train$target = train$target - 1
#library(Metrics)
#library(caret)
n_folds = 10
folds_i = sample(rep(1:n_folds, length.out = nrow(train)))
cv_tmp <- matrix(NA,nrow = n_folds, ncol = length(train))
global_misClasificError = 0
for(k in 1:n_folds){
test_i <- which(folds_i == k)
train_ <- train[-test_i,]
test_ <- train[test_i,]
model <- glm(train_$target ~.,family=binomial(link='logit'),data=train_)
prediction = predict(model, test_, type="response")
fitted.results <- ifelse(prediction > 0.5,1,0)
misClasificError <- mean(fitted.results != test_$target)
print(paste('Accuracy fold',k,'-' ,1-misClasificError))
global_misClasificError = global_misClasificError + (1-misClasificError)
if( k==1 ) ideal1 <- test_$target
if( k==2 ) ideal2 <- test_$target
if( k==3 ) ideal3 <- test_$target
if( k==4 ) ideal4 <- test_$target
if( k==5 ) ideal5 <- test_$target
if( k==6 ) ideal6 <- test_$target
if( k==7 ) ideal7 <- test_$target
if( k==8 ) ideal8 <- test_$target
if( k==9 ) ideal9 <- test_$target
if( k==10 ) ideal10 <- test_$target
if( k==1 ) prediction1 <- fitted.results
if( k==2 ) prediction2 <- fitted.results
if( k==3 ) prediction3 <- fitted.results
if( k==4 ) prediction4 <- fitted.results
if( k==5 ) prediction5 <- fitted.results
if( k==6 ) prediction6 <- fitted.results
if( k==7 ) prediction7 <- fitted.results
if( k==8 ) prediction8 <- fitted.results
if( k==9 ) prediction9 <- fitted.results
if( k==10 ) prediction10 <- fitted.results
}
ideal <- rbind(ideal1, ideal2, ideal3, ideal4, ideal5, ideal6, ideal7, ideal8, ideal9, ideal10 )
prediction <- rbind(prediction1, prediction2, prediction3, prediction4, prediction5,
prediction6, prediction7, prediction8, prediction9, prediction10 )
confusionMatrix(prediction, ideal)
library(Amelia)
install.packages(Amelia)
install.packages('Amelia')
library(gridExtra)
library(plyr)
getwd()
path="/Users/ctrabuco/Desktop/us_census_full/code"
setwd(path)
# Input data files are available in the "../input/" directory.
cat("reading the train and test data\n")
train  <- read.csv("../input/census_income_learn.csv",head=FALSE, na.strings=c("?"," ?"))
test  <- read.csv("../input/census_income_test.csv",head=FALSE, na.strings=c("?"," ?"))
columns_data <- c("age",
"class_of_worker",
"detailed_industry_recode",
"detailed_occupation_recode",
"education",
"wage_per_hour",
"enroll_in_edu_inst_last_wk",
"marital_stat",
"major_industry_code",
"major_occupation_code",
"race",
"hispanic_origin",
"sex",
"member_of_a_labor_union",
"reason_for_unemployment",
"full_or_part_time_employment_stat",
"capital_gains",
"capital_losses",
"dividends_from_stocks",
"tax_filer_stat",
"region_of_previous_residence",
"state_of_previous_residence",
"detailed_household_and_family_stat",
"detailed_household_summary_in_hous",
"instance_weight", # ignore (?)
"migration_code-change_in_msa",
"migration_code-change_in_reg",
"migration_code-move_within_reg",
"live_in_this_house_1_year_ago",
"migration_prev_res_in_sunbelt",
"num_persons_worked_for_employer",
"family_members_under_18",
"country_of_birth_father",
"country_of_birth_mother",
"country_of_birth_self",
"citizenship",
"own_business_or_self_employed",
"fill_inc_questionnaire_for_veteran",
"veterans_benefits",
"weeks_worked_in_year",
"year",
"target")
colnames(train) <- columns_data
attach(train)
names(train)
## view how many unique values are for each variable
## (just to check with the metadata file)
uniques <- as.data.frame(sapply(train, function(x) length(unique(x))))
uniques <- rename(uniques,c("sapply(train, function(x) length(unique(x)))" = "number_of_values"))
##################################
# percentage of missing values per variable
##################################
missing_values <- as.data.frame(colMeans(is.na(train)))
missing_values <- rename(missing_values, c("colMeans(is.na(train))"="percentage"))
#show only the columns with missing values
missing_values<-subset(missing_values,missing_values$percentage!=0)
#export into pdf
pdf("../reports/missing_values_percentage.pdf")
grid.table(missing_values)
dev.off()
library(Amelia)
missmap(train, main = "Missing values vs observed")
pdf("../reports/missing_values_graphic.pdf")
missmap(train, main = "Missing values vs observed")
dev.off()
missmap(train, main = "Missing values vs observed")
pdf("../reports/missing_values_percentage.pdf")
missmap(train, main = "Missing values vs observed")
dev.off()
#export into pdf
pdf("../reports/missing_values_percentage.pdf")
grid.table(missing_values)
dev.off()
